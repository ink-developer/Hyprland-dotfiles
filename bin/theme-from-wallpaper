#!/usr/bin/env bash
set -euo pipefail

# ============ config ============
WALLDIR="$HOME/Documents/wallpaper"
LOCK="/tmp/theme-from-wallpaper.lock"
LOGFILE="$HOME/.cache/theme-from-wallpaper.log"

mkdir -p "$(dirname "$LOGFILE")"

# ============ pretty logs ============
if command -v tput >/dev/null 2>&1; then
  BOLD="$(tput bold)"; DIM="$(tput dim)"
  RED="$(tput setaf 1)"; GRN="$(tput setaf 2)"; YLW="$(tput setaf 3)"; BLU="$(tput setaf 4)"
  RST="$(tput sgr0)"
else
  BOLD=""; DIM=""; RED=""; GRN=""; YLW=""; BLU=""; RST=""
fi

ts() { date +"%H:%M:%S"; }

log()  { printf "%s ℹ %s\n" "$(ts)" "$*" | sed "s/\x1b\[[0-9;]*m//g" >>"$LOGFILE"; printf "%s ${BLU}ℹ${RST} %s\n" "$(ts)" "$*" >&2; }
ok()   { printf "%s ${GRN}✔${RST} %s\n" "$(ts)" "$*" | tee -a "$LOGFILE" >&2; }
warn() { printf "%s ${YLW}⚠${RST} %s\n" "$(ts)" "$*" | tee -a "$LOGFILE" >&2; }
err()  { printf "%s ${RED}✖${RST} %s\n" "$(ts)" "$*" | tee -a "$LOGFILE" >&2; }

die() { err "$*"; exit 1; }

need() { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: ${BOLD}$1${RST}"; }

step_start() { _STEP_NAME="$1"; _T0="$(date +%s%3N 2>/dev/null || date +%s)"; log "${BOLD}${_STEP_NAME}${RST}"; }
step_end() {
  local t1
  t1="$(date +%s%3N 2>/dev/null || date +%s)"
  if [[ "$_T0" =~ ^[0-9]+$ && "$t1" =~ ^[0-9]+$ ]]; then
    ok "${_STEP_NAME} ${DIM}(${t1}-${_T0})${RST}"
  else
    ok "${_STEP_NAME}"
  fi
}

trap 'err "Failed at line ${LINENO}: ${BASH_COMMAND} (exit $?)"' ERR

# ============ lock (robust: external flock wrapper style) ============
# We keep lock handling minimal and release before spawning any daemon.
exec {lockfd}>"$LOCK"
if ! flock -n "$lockfd"; then
  warn "Another instance is running (lock: $LOCK). Exiting."
  exit 0
fi

cleanup_lock() {
  flock -u "$lockfd" 2>/dev/null || true
  exec {lockfd}>&- 2>/dev/null || true
}
trap cleanup_lock EXIT

# ============ deps ============
need swww
need wal
need jq
need flock

# ============ pick wallpaper ============
if [[ $# -ge 1 ]]; then
  WALL="$1"
else
  WALL="$(find "$WALLDIR" -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.png" -o -iname "*.jpeg" \) | shuf -n 1)"
fi

[[ -n "${WALL:-}" ]] || die "No wallpaper selected (dir: $WALLDIR)"
[[ -f "$WALL" ]] || die "Wallpaper not found: $WALL"

log "Wallpaper: ${BOLD}$WALL${RST}"

# ============ swww daemon ============
step_start "swww: ensure daemon"
if ! swww query >/dev/null 2>&1; then
  if ! pgrep -x swww-daemon >/dev/null 2>&1; then
    # Important: release lock BEFORE spawning background process to avoid FD inheritance issues.
    cleanup_lock
    trap - EXIT

    swww-daemon >/dev/null 2>&1 &

    # Wait for daemon readiness (more reliable than sleep 0.2)
    for _ in {1..15}; do
      swww query >/dev/null 2>&1 && break
      sleep 0.1
    done
  fi
fi
step_end

# ============ wallpaper ============
step_start "swww: set wallpaper"
swww img "$WALL" --transition-type any --transition-fps 60 --transition-duration 1
step_end

# ============ pywal ============
step_start "pywal: generate palette"
wal -n -i "$WALL" >/dev/null
step_end

JSON="$HOME/.cache/wal/colors.json"
[[ -f "$JSON" ]] || die "pywal did not create $JSON"

# Read everything with one jq call (faster + cleaner)
read -r bg fg c0 c1 c2 c3 c4 c5 c6 c7 < <(
  jq -r '
    [
      .special.background,
      .special.foreground,
      .colors.color0,.colors.color1,.colors.color2,.colors.color3,
      .colors.color4,.colors.color5,.colors.color6,.colors.color7
    ] | @tsv
  ' "$JSON"
)

# ============ waybar ============
step_start "waybar: write colors.css"
mkdir -p "$HOME/.config/waybar"
cat > "$HOME/.config/waybar/colors.css" <<EOF
/* generated by theme-from-wallpaper (pywal) */
@define-color bg ${bg};
@define-color fg ${fg};

@define-color c0 ${c0};
@define-color c1 ${c1};
@define-color c2 ${c2};
@define-color c3 ${c3};
@define-color c4 ${c4};
@define-color c5 ${c5};
@define-color c6 ${c6};
@define-color c7 ${c7};
EOF
step_end

# ============ kitty ============
step_start "kitty: write colors.conf"
mkdir -p "$HOME/.config/kitty"
cat > "$HOME/.config/kitty/colors.conf" <<EOF
# generated by theme-from-wallpaper (pywal)
background ${bg}
foreground ${fg}

color0  ${c0}
color1  ${c1}
color2  ${c2}
color3  ${c3}
color4  ${c4}
color5  ${c5}
color6  ${c6}
color7  ${c7}
EOF
step_end

# ============ wofi ============
step_start "wofi: write colors.css"
mkdir -p "$HOME/.config/wofi"
cat > "$HOME/.config/wofi/colors.css" <<EOF
/* generated by theme-from-wallpaper (pywal) */
@define-color bg ${bg};
@define-color fg ${fg};

@define-color c0 ${c0};
@define-color c1 ${c1};
@define-color c2 ${c2};
@define-color c3 ${c3};
@define-color c4 ${c4};
@define-color c5 ${c5};
@define-color c6 ${c6};
@define-color c7 ${c7};
EOF
step_end

# ============ reload waybar ============
step_start "waybar: restart"
if systemctl --user is-active --quiet waybar.service 2>/dev/null; then
  systemctl --user restart waybar.service || true
else
  pkill waybar 2>/dev/null || true
  (nohup waybar >/dev/null 2>&1 &) || true
fi
step_end

# ============ apply kitty live ============
step_start "kitty: apply live"
if pgrep -x kitty >/dev/null 2>&1; then
  kitty @ set-colors -a "$HOME/.config/kitty/colors.conf" 2>/dev/null || true
fi
step_end

to_hypr_rgba() {
  local hex="${1#\#}"     # strip leading #
  printf "%sff" "$hex"    # add alpha FF
}

ab1="$(to_hypr_rgba "$c1")"
ab2="$(to_hypr_rgba "$c5")"
ib="$(to_hypr_rgba "$c0")"

cat > "$HOME/.config/hypr/colors.conf" <<EOF
# generated by theme-from-wallpaper (pywal)
general {
  col.active_border = rgba(${ab1}) rgba(${ab2}) 45deg
  col.inactive_border = rgba(${ib})
}
EOF

# reload hyprland to apply
hyprctl reload >/dev/null 2>&1 || true

ok "Done"
